ToDo List:

- [ ] All CI pipelines should on success print report in logs and summary:
  - [ ] Link that triggers next state of the release, for example: from pre-release promote to release;
  - [ ] Link that triggers rollback to previous state of the release with clear messaging to which version will be rolled back to;
  - [ ] Link that triggers manual state assignment: stable or unstable;
  - [ ] Link that triggers maintenance in different modes: cleanup, sync-files, deprecate-old-versions, security-audit, dependency-update, all;
  - [ ] New basis defining: initial release, pre-release, release, hotfix, stable, unstable, deprecated;
- [ ] Implement advanced git tags system that will control the deployment process to different environments: staging, production (optional: performance, sandbox, canary);
  - [ ] We should support monorepo, which contains multiple sub-projects available for deployment.
  - [ ] We should operate the fix amount of predefined tags, each tag associated with the deployment of the specific sub-project to the specific environment. For example: if developer assign tag 'production' to the commit with semver version tag 'v1.0.0' then CI treats this as a request to deploy version 'v1.0.0' to production environment. If we need to deploy the same version of the project to all environments we should assign tags 'production', 'staging', 'sandbox', 'canary' to the same commit.
  - [ ] Tags can be assigned to commits in other branches, that are not merged into MAIN branch.
  - [ ] Environment tags should be assignable only via specific CI pipeline, developer cannot assign specially selected by us tags to commit directly. git hooks should prevent this action. ci should prevent this action.
  - [ ] Tags should follow the pattern in names: `<path>/<version>` where `<path>` is the path to the sub-project and `<version>` is the version of the sub-project. for the ROOT project `<path>` should be empty string. for example: `v1.0.0`, `sub-project/v1.0.0`
  - [ ] Stable and unstable, deprecated states should be assigned by additional tags, that following the same pattern: `<path>/<version>-stable` and `<path>/<version>-unstable`, `<path>/<version>-deprecated`
  - [ ] Admin of the project can modify tags directly. 
- [ ] Environments Support. Solution should provide easy way to support multiple deploy environments: staging, production (optional: performance, sandbox, canary);
  - [ ] Each environment should have own sub-folder which will accumulate files with unique values/parameters required for deployment
  - [ ] We can support Regions. When we are deploy to region in scope of specific environment.
  - [ ] We should support Global scope, which used for resources that are cross environment. We need the same for regions.
  - [ ] we should be cloud agnostic, so regions should be names that we map to a cloud specific values.
  - [ ] MISE should support "profile" switching, so when we switch a profile become specific environment and region active. 
    - [ ] we will need a ZSH (oh-my-zsh) plugin for supporting visualization of the current profile in shell prompt (with easy installation via MISE tasks).
- [ ] CI scripts organisation. CI pipelines should stay "dry" with minimal logic in them.
  - [ ] all steps should be in separated BASH (or Typescript) file, that can be called from the pipeline
  - [ ] MISE tools should be used to guaranty that a specific required tool is installed and available. No need to double check availability of tools in the pipeline scripts.
  - [ ] scripts that are a part of the CI pipeline should follow the pattern name: `ci-<script-name>.sh`; if we have scripts that should be executed in special order, we should use order prefix: `<NN>-ci-<script-name>.sh` where `<NN>` is the order number (with leading zeros). NN should be in range from 00 to 99 and allowed gaps between numbers, so we left some space for future scripts in the "middle", recommended step "10" (for example: 00, 10, 20, 30, 40, 50, 60, 70, 80, 90. if we need something in the middle we can use for example: 55, 05, 95. rule is always take a middle number in the range). In all other cases we should refactor the script names.
  - [ ] allowed usage of sub-folder for structiring script files, we use folder name as a logic scope for script. for example: `ci-compile.sh` can be in `scripts/compile/01-ci-compile-step.sh`.
- [ ] Scripts as a placeholder. All scripts by default should not have any implementation, they are designed to be used as a starting point for the developer. Developer will fill scripts with required functionality. But all scripts from the beggining should provide TESTABILITY:
  - [ ] All scripts should have comments, that explain what the script does and how to use it.
  - [ ] All scripts should listen to global environment variable, that indicate that we are executing in a testing mode. In testing mode each script listen to own global environment variable that defines the behavior: FAIL, PASS, SKIP, TIMEOUT, DRY_RUN, EXECUTE. In execute mode - script should execute its functionality, in other modes - script should return appropriate exit code and message to the user. In DRY_RUN mode script just print commands that plan to execute, without any real modification of state (it means that ReadOnly mode is active and we can fetch data, but not modify it).
  - [ ] During CI testing developer can create a configuration matrix that will execute every possible path of the script.
  - [ ] We should be able to execute any pipeline manually or via webhook.
    - [ ] we may need some restrictions (like basic auth) to prevent unauthorized access to the pipeline execution.
- [ ] Minimalistic configuration. If CI job/step detects that it has sufficient data for execution, and it is not specifically disabled by user, it should execute. That makes possible for example enable Notifications as soon as we register in CI required token for notifications. 
- [ ] Quality gates. We should try to provide minimalistic scripts, rely on other tools like MISE and githooks to control the environment.
  - [ ] No security leaks (credentials, tokens, etc.)
  - [ ] Always provide a secret-rotation mechanism and document it. Keep information in SECURITY.md file. Focus on one secret rotation per script. 
  - [ ] Focus on small scripts with clear functionality and minimal dependencies. each script prefered size is less than 50 LOC.
  - [ ] Establish stable environment and dependencies, avoid usage of tags like `latest` or `next`. better always use specific version tags.
  - [ ] Lint, Formatting, Unit tests, Security tests, Performance tests, etc. - all should become a part of the githook and CI. Possible editing via web-browser (without fully established environment) so we should be able to format code in the moment of commit/push OR trigger a special pipeline for that (`self healing` sounds like a good name for that). 